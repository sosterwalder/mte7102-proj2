% -*- coding: UTF-8 -*-
% vim: autoindent expandtab tabstop=4 sw=4 sts=4 filetype=tex
% vim: spelllang=de spell
% chktex-file 27 - disable warning about missing include files

\chapter{Rendering}
\label{chap:rendering}


Um schliesslich die erstellte Echtzeit-Animationen auch darstellen zu können
--- im Editor und im Player --- wird ein Rendering-Verfahren benötigt.

Als Rendering-Verfahren soll primär das Ray-Tracing-Verfahren Sphere-Tracing
zum Einsatz kommen. Auf dieses wird hier nicht eingegangen, da dieses
bereits ausführlich in der vorhergehenden Projektarbeit behandelt wurde
(siehe~\cite{osterwalder_sven_volume_2016}).

Da bei der vorhergehenden Projektarbeit die~\textit{Berechnung von
    Normalen-Vektoren}, die \textit{Repetitions-Operation} und deren
\textit{Komplexität} nicht ausreichend geklärt wurden beziehungsweise bei der
Projektarbeit Fragen dazu aufkamen, werden die Punkte an dieser Stelle genauer
erläutert. Weiter wird ein möglicher Ansatz gezeigt, um \textit{herkömmliche
    3D-Modelle (Meshes)} mittels Sphere-Tracing darstellen zu können.

Als Grundlage für das Rendering wird OpenGL gewählt, da diese Bibliothek
plattformübergreifend und quelloffen ist. Mit der Einführung der Version 3 von
OpenGL, beziehungsweise Version 2 von OpenGL ES, wurde die Rendering-Pipeline
dahingehend geändert, dass diese nun nicht mehr fix vorgegeben sondern frei
programmierbar
ist\cite{opengl_foundation_fixed_2015}~\cite{opengl_foundation_rendering_2015}.
So gesehen findet das Rendering spätestens seit OpenGL Version 3
beziehungsweise OpenGL ES Version 2 immer per Shader statt. Ist der Aufwand der 
Programmierung der Rendering-Pipeline initial grösser, so ist eine frei
programmierbare Pipeline jedoch viel flexibler.

Genau dieser Ansatz soll auch in der hier vorgestellten Software-Architektur
für das Rendering verwendet werden: Ein modulares Rendering, welches jederzeit
ersetzt werden kann. Da alles via Shader gerendert wird, ist dies so gesehen
bereits gegeben. Szenen können --- im Falle von Sphere-Tracing --- rein aus
internen Funktionen und Daten bestehen oder aber --- im Falle der Verwendung
von herkömmlichen Modellen (Meshes) --- externe Daten beinhalten. So wäre
beispielsweise zusätzlich zu Sphere-Tracing
Deferred-Rendering~\footnotetext{\url{https://sites.google.com/site/richgel99/home}}~\parencite{saito_comprehensible_1990}
denkbar. Die Schnittstelle zwischen der Applikation und Shader, in Form von
Uniform-Variablen, wird aber so oder benötigt um auf der CPU berechnete
Matrizen an den Shader respektive die GPU weiterzureichen.

\input{inc/70/normal_vectors}
\input{inc/70/modulo_op}
\input{inc/70/complexity}
\input{inc/70/meshes}
